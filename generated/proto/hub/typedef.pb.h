// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: typedef.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_typedef_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_typedef_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_typedef_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_typedef_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_typedef_2eproto;
class Buffer;
struct BufferDefaultTypeInternal;
extern BufferDefaultTypeInternal _Buffer_default_instance_;
class KeepAlive_t;
struct KeepAlive_tDefaultTypeInternal;
extern KeepAlive_tDefaultTypeInternal _KeepAlive_t_default_instance_;
class Led_t;
struct Led_tDefaultTypeInternal;
extern Led_tDefaultTypeInternal _Led_t_default_instance_;
class Ota_t;
struct Ota_tDefaultTypeInternal;
extern Ota_tDefaultTypeInternal _Ota_t_default_instance_;
class Sw_t;
struct Sw_tDefaultTypeInternal;
extern Sw_tDefaultTypeInternal _Sw_t_default_instance_;
class Sync_t;
struct Sync_tDefaultTypeInternal;
extern Sync_tDefaultTypeInternal _Sync_t_default_instance_;
class Timer_t;
struct Timer_tDefaultTypeInternal;
extern Timer_tDefaultTypeInternal _Timer_t_default_instance_;
class Vendor_t;
struct Vendor_tDefaultTypeInternal;
extern Vendor_tDefaultTypeInternal _Vendor_t_default_instance_;
class Vpn_t;
struct Vpn_tDefaultTypeInternal;
extern Vpn_tDefaultTypeInternal _Vpn_t_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Buffer* Arena::CreateMaybeMessage<::Buffer>(Arena*);
template<> ::KeepAlive_t* Arena::CreateMaybeMessage<::KeepAlive_t>(Arena*);
template<> ::Led_t* Arena::CreateMaybeMessage<::Led_t>(Arena*);
template<> ::Ota_t* Arena::CreateMaybeMessage<::Ota_t>(Arena*);
template<> ::Sw_t* Arena::CreateMaybeMessage<::Sw_t>(Arena*);
template<> ::Sync_t* Arena::CreateMaybeMessage<::Sync_t>(Arena*);
template<> ::Timer_t* Arena::CreateMaybeMessage<::Timer_t>(Arena*);
template<> ::Vendor_t* Arena::CreateMaybeMessage<::Vendor_t>(Arena*);
template<> ::Vpn_t* Arena::CreateMaybeMessage<::Vpn_t>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum User_t : int {
  App = 0,
  Server = 1,
  Hub = 2,
  Zigbee = 3,
  Ble = 4,
  Ai = 5,
  Wifi = 6,
  Screen = 7,
  Ota = 8,
  User_t_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  User_t_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool User_t_IsValid(int value);
constexpr User_t User_t_MIN = App;
constexpr User_t User_t_MAX = Ota;
constexpr int User_t_ARRAYSIZE = User_t_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* User_t_descriptor();
template<typename T>
inline const std::string& User_t_Name(T enum_t_value) {
  static_assert(::std::is_same<T, User_t>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function User_t_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    User_t_descriptor(), enum_t_value);
}
inline bool User_t_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, User_t* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<User_t>(
    User_t_descriptor(), name, value);
}
// ===================================================================

class Led_t final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Led_t) */ {
 public:
  inline Led_t() : Led_t(nullptr) {}
  ~Led_t() override;
  explicit PROTOBUF_CONSTEXPR Led_t(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Led_t(const Led_t& from);
  Led_t(Led_t&& from) noexcept
    : Led_t() {
    *this = ::std::move(from);
  }

  inline Led_t& operator=(const Led_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline Led_t& operator=(Led_t&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Led_t& default_instance() {
    return *internal_default_instance();
  }
  static inline const Led_t* internal_default_instance() {
    return reinterpret_cast<const Led_t*>(
               &_Led_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Led_t& a, Led_t& b) {
    a.Swap(&b);
  }
  inline void Swap(Led_t* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Led_t* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Led_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Led_t>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Led_t& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Led_t& from) {
    Led_t::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Led_t* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Led_t";
  }
  protected:
  explicit Led_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 16,
    kMacFieldNumber = 17,
    kEpFieldNumber = 18,
    kStatusFieldNumber = 19,
  };
  // string name = 16;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 mac = 17;
  void clear_mac();
  uint64_t mac() const;
  void set_mac(uint64_t value);
  private:
  uint64_t _internal_mac() const;
  void _internal_set_mac(uint64_t value);
  public:

  // uint32 ep = 18;
  void clear_ep();
  uint32_t ep() const;
  void set_ep(uint32_t value);
  private:
  uint32_t _internal_ep() const;
  void _internal_set_ep(uint32_t value);
  public:

  // bool status = 19;
  void clear_status();
  bool status() const;
  void set_status(bool value);
  private:
  bool _internal_status() const;
  void _internal_set_status(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Led_t)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint64_t mac_;
    uint32_t ep_;
    bool status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_typedef_2eproto;
};
// -------------------------------------------------------------------

class Sync_t final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sync_t) */ {
 public:
  inline Sync_t() : Sync_t(nullptr) {}
  ~Sync_t() override;
  explicit PROTOBUF_CONSTEXPR Sync_t(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sync_t(const Sync_t& from);
  Sync_t(Sync_t&& from) noexcept
    : Sync_t() {
    *this = ::std::move(from);
  }

  inline Sync_t& operator=(const Sync_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sync_t& operator=(Sync_t&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sync_t& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sync_t* internal_default_instance() {
    return reinterpret_cast<const Sync_t*>(
               &_Sync_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Sync_t& a, Sync_t& b) {
    a.Swap(&b);
  }
  inline void Swap(Sync_t* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sync_t* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sync_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sync_t>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sync_t& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Sync_t& from) {
    Sync_t::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sync_t* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sync_t";
  }
  protected:
  explicit Sync_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddFieldNumber = 16,
    kRemoveFieldNumber = 17,
    kSyncFieldNumber = 18,
  };
  // bool add = 16;
  void clear_add();
  bool add() const;
  void set_add(bool value);
  private:
  bool _internal_add() const;
  void _internal_set_add(bool value);
  public:

  // bool remove = 17;
  void clear_remove();
  bool remove() const;
  void set_remove(bool value);
  private:
  bool _internal_remove() const;
  void _internal_set_remove(bool value);
  public:

  // bool sync = 18;
  void clear_sync();
  bool sync() const;
  void set_sync(bool value);
  private:
  bool _internal_sync() const;
  void _internal_set_sync(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Sync_t)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool add_;
    bool remove_;
    bool sync_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_typedef_2eproto;
};
// -------------------------------------------------------------------

class Sw_t final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sw_t) */ {
 public:
  inline Sw_t() : Sw_t(nullptr) {}
  ~Sw_t() override;
  explicit PROTOBUF_CONSTEXPR Sw_t(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sw_t(const Sw_t& from);
  Sw_t(Sw_t&& from) noexcept
    : Sw_t() {
    *this = ::std::move(from);
  }

  inline Sw_t& operator=(const Sw_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sw_t& operator=(Sw_t&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sw_t& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sw_t* internal_default_instance() {
    return reinterpret_cast<const Sw_t*>(
               &_Sw_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Sw_t& a, Sw_t& b) {
    a.Swap(&b);
  }
  inline void Swap(Sw_t* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sw_t* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sw_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sw_t>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sw_t& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Sw_t& from) {
    Sw_t::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sw_t* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sw_t";
  }
  protected:
  explicit Sw_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 16,
    kMacFieldNumber = 18,
    kEpFieldNumber = 17,
    kStatusFieldNumber = 19,
  };
  // string name = 16;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 mac = 18;
  void clear_mac();
  uint64_t mac() const;
  void set_mac(uint64_t value);
  private:
  uint64_t _internal_mac() const;
  void _internal_set_mac(uint64_t value);
  public:

  // uint32 ep = 17;
  void clear_ep();
  uint32_t ep() const;
  void set_ep(uint32_t value);
  private:
  uint32_t _internal_ep() const;
  void _internal_set_ep(uint32_t value);
  public:

  // bool status = 19;
  void clear_status();
  bool status() const;
  void set_status(bool value);
  private:
  bool _internal_status() const;
  void _internal_set_status(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Sw_t)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint64_t mac_;
    uint32_t ep_;
    bool status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_typedef_2eproto;
};
// -------------------------------------------------------------------

class Ota_t final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Ota_t) */ {
 public:
  inline Ota_t() : Ota_t(nullptr) {}
  ~Ota_t() override;
  explicit PROTOBUF_CONSTEXPR Ota_t(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ota_t(const Ota_t& from);
  Ota_t(Ota_t&& from) noexcept
    : Ota_t() {
    *this = ::std::move(from);
  }

  inline Ota_t& operator=(const Ota_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ota_t& operator=(Ota_t&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ota_t& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ota_t* internal_default_instance() {
    return reinterpret_cast<const Ota_t*>(
               &_Ota_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Ota_t& a, Ota_t& b) {
    a.Swap(&b);
  }
  inline void Swap(Ota_t* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ota_t* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ota_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ota_t>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ota_t& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ota_t& from) {
    Ota_t::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ota_t* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Ota_t";
  }
  protected:
  explicit Ota_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCheckOtaFieldNumber = 16,
    kStatusFieldNumber = 17,
    kAckFieldNumber = 18,
  };
  // bool check_ota = 16;
  void clear_check_ota();
  bool check_ota() const;
  void set_check_ota(bool value);
  private:
  bool _internal_check_ota() const;
  void _internal_set_check_ota(bool value);
  public:

  // bool status = 17;
  void clear_status();
  bool status() const;
  void set_status(bool value);
  private:
  bool _internal_status() const;
  void _internal_set_status(bool value);
  public:

  // bool ack = 18;
  void clear_ack();
  bool ack() const;
  void set_ack(bool value);
  private:
  bool _internal_ack() const;
  void _internal_set_ack(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Ota_t)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool check_ota_;
    bool status_;
    bool ack_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_typedef_2eproto;
};
// -------------------------------------------------------------------

class KeepAlive_t final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KeepAlive_t) */ {
 public:
  inline KeepAlive_t() : KeepAlive_t(nullptr) {}
  ~KeepAlive_t() override;
  explicit PROTOBUF_CONSTEXPR KeepAlive_t(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeepAlive_t(const KeepAlive_t& from);
  KeepAlive_t(KeepAlive_t&& from) noexcept
    : KeepAlive_t() {
    *this = ::std::move(from);
  }

  inline KeepAlive_t& operator=(const KeepAlive_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeepAlive_t& operator=(KeepAlive_t&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeepAlive_t& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeepAlive_t* internal_default_instance() {
    return reinterpret_cast<const KeepAlive_t*>(
               &_KeepAlive_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(KeepAlive_t& a, KeepAlive_t& b) {
    a.Swap(&b);
  }
  inline void Swap(KeepAlive_t* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeepAlive_t* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeepAlive_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeepAlive_t>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeepAlive_t& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeepAlive_t& from) {
    KeepAlive_t::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeepAlive_t* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KeepAlive_t";
  }
  protected:
  explicit KeepAlive_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
  };
  // .User_t sender = 1;
  void clear_sender();
  ::User_t sender() const;
  void set_sender(::User_t value);
  private:
  ::User_t _internal_sender() const;
  void _internal_set_sender(::User_t value);
  public:

  // @@protoc_insertion_point(class_scope:KeepAlive_t)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int sender_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_typedef_2eproto;
};
// -------------------------------------------------------------------

class Timer_t final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Timer_t) */ {
 public:
  inline Timer_t() : Timer_t(nullptr) {}
  ~Timer_t() override;
  explicit PROTOBUF_CONSTEXPR Timer_t(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Timer_t(const Timer_t& from);
  Timer_t(Timer_t&& from) noexcept
    : Timer_t() {
    *this = ::std::move(from);
  }

  inline Timer_t& operator=(const Timer_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline Timer_t& operator=(Timer_t&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Timer_t& default_instance() {
    return *internal_default_instance();
  }
  static inline const Timer_t* internal_default_instance() {
    return reinterpret_cast<const Timer_t*>(
               &_Timer_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Timer_t& a, Timer_t& b) {
    a.Swap(&b);
  }
  inline void Swap(Timer_t* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Timer_t* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Timer_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Timer_t>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Timer_t& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Timer_t& from) {
    Timer_t::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Timer_t* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Timer_t";
  }
  protected:
  explicit Timer_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDayFieldNumber = 15,
    kMonthFieldNumber = 16,
    kHourFieldNumber = 17,
    kMinuteFieldNumber = 18,
  };
  // uint32 day = 15;
  void clear_day();
  uint32_t day() const;
  void set_day(uint32_t value);
  private:
  uint32_t _internal_day() const;
  void _internal_set_day(uint32_t value);
  public:

  // uint32 month = 16;
  void clear_month();
  uint32_t month() const;
  void set_month(uint32_t value);
  private:
  uint32_t _internal_month() const;
  void _internal_set_month(uint32_t value);
  public:

  // uint32 hour = 17;
  void clear_hour();
  uint32_t hour() const;
  void set_hour(uint32_t value);
  private:
  uint32_t _internal_hour() const;
  void _internal_set_hour(uint32_t value);
  public:

  // uint32 minute = 18;
  void clear_minute();
  uint32_t minute() const;
  void set_minute(uint32_t value);
  private:
  uint32_t _internal_minute() const;
  void _internal_set_minute(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Timer_t)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t day_;
    uint32_t month_;
    uint32_t hour_;
    uint32_t minute_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_typedef_2eproto;
};
// -------------------------------------------------------------------

class Buffer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Buffer) */ {
 public:
  inline Buffer() : Buffer(nullptr) {}
  ~Buffer() override;
  explicit PROTOBUF_CONSTEXPR Buffer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Buffer(const Buffer& from);
  Buffer(Buffer&& from) noexcept
    : Buffer() {
    *this = ::std::move(from);
  }

  inline Buffer& operator=(const Buffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Buffer& operator=(Buffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Buffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Buffer* internal_default_instance() {
    return reinterpret_cast<const Buffer*>(
               &_Buffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Buffer& a, Buffer& b) {
    a.Swap(&b);
  }
  inline void Swap(Buffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Buffer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Buffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Buffer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Buffer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Buffer& from) {
    Buffer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Buffer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Buffer";
  }
  protected:
  explicit Buffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLedFieldNumber = 18,
    kSwFieldNumber = 19,
    kMacHubFieldNumber = 1,
    kSyncFieldNumber = 5,
    kOtaFieldNumber = 16,
    kVpnFieldNumber = 17,
    kTimeFieldNumber = 20,
    kSenderFieldNumber = 2,
    kReceiverFieldNumber = 3,
    kCotrollerFieldNumber = 4,
  };
  // repeated .Led_t led = 18;
  int led_size() const;
  private:
  int _internal_led_size() const;
  public:
  void clear_led();
  ::Led_t* mutable_led(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Led_t >*
      mutable_led();
  private:
  const ::Led_t& _internal_led(int index) const;
  ::Led_t* _internal_add_led();
  public:
  const ::Led_t& led(int index) const;
  ::Led_t* add_led();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Led_t >&
      led() const;

  // repeated .Sw_t sw = 19;
  int sw_size() const;
  private:
  int _internal_sw_size() const;
  public:
  void clear_sw();
  ::Sw_t* mutable_sw(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Sw_t >*
      mutable_sw();
  private:
  const ::Sw_t& _internal_sw(int index) const;
  ::Sw_t* _internal_add_sw();
  public:
  const ::Sw_t& sw(int index) const;
  ::Sw_t* add_sw();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Sw_t >&
      sw() const;

  // string mac_hub = 1;
  void clear_mac_hub();
  const std::string& mac_hub() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac_hub(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac_hub();
  PROTOBUF_NODISCARD std::string* release_mac_hub();
  void set_allocated_mac_hub(std::string* mac_hub);
  private:
  const std::string& _internal_mac_hub() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_hub(const std::string& value);
  std::string* _internal_mutable_mac_hub();
  public:

  // .Sync_t sync = 5;
  bool has_sync() const;
  private:
  bool _internal_has_sync() const;
  public:
  void clear_sync();
  const ::Sync_t& sync() const;
  PROTOBUF_NODISCARD ::Sync_t* release_sync();
  ::Sync_t* mutable_sync();
  void set_allocated_sync(::Sync_t* sync);
  private:
  const ::Sync_t& _internal_sync() const;
  ::Sync_t* _internal_mutable_sync();
  public:
  void unsafe_arena_set_allocated_sync(
      ::Sync_t* sync);
  ::Sync_t* unsafe_arena_release_sync();

  // .Ota_t ota = 16;
  bool has_ota() const;
  private:
  bool _internal_has_ota() const;
  public:
  void clear_ota();
  const ::Ota_t& ota() const;
  PROTOBUF_NODISCARD ::Ota_t* release_ota();
  ::Ota_t* mutable_ota();
  void set_allocated_ota(::Ota_t* ota);
  private:
  const ::Ota_t& _internal_ota() const;
  ::Ota_t* _internal_mutable_ota();
  public:
  void unsafe_arena_set_allocated_ota(
      ::Ota_t* ota);
  ::Ota_t* unsafe_arena_release_ota();

  // .Vpn_t vpn = 17;
  bool has_vpn() const;
  private:
  bool _internal_has_vpn() const;
  public:
  void clear_vpn();
  const ::Vpn_t& vpn() const;
  PROTOBUF_NODISCARD ::Vpn_t* release_vpn();
  ::Vpn_t* mutable_vpn();
  void set_allocated_vpn(::Vpn_t* vpn);
  private:
  const ::Vpn_t& _internal_vpn() const;
  ::Vpn_t* _internal_mutable_vpn();
  public:
  void unsafe_arena_set_allocated_vpn(
      ::Vpn_t* vpn);
  ::Vpn_t* unsafe_arena_release_vpn();

  // .Timer_t time = 20;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::Timer_t& time() const;
  PROTOBUF_NODISCARD ::Timer_t* release_time();
  ::Timer_t* mutable_time();
  void set_allocated_time(::Timer_t* time);
  private:
  const ::Timer_t& _internal_time() const;
  ::Timer_t* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::Timer_t* time);
  ::Timer_t* unsafe_arena_release_time();

  // .User_t sender = 2;
  void clear_sender();
  ::User_t sender() const;
  void set_sender(::User_t value);
  private:
  ::User_t _internal_sender() const;
  void _internal_set_sender(::User_t value);
  public:

  // .User_t receiver = 3;
  void clear_receiver();
  ::User_t receiver() const;
  void set_receiver(::User_t value);
  private:
  ::User_t _internal_receiver() const;
  void _internal_set_receiver(::User_t value);
  public:

  // .User_t cotroller = 4;
  void clear_cotroller();
  ::User_t cotroller() const;
  void set_cotroller(::User_t value);
  private:
  ::User_t _internal_cotroller() const;
  void _internal_set_cotroller(::User_t value);
  public:

  // @@protoc_insertion_point(class_scope:Buffer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Led_t > led_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Sw_t > sw_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_hub_;
    ::Sync_t* sync_;
    ::Ota_t* ota_;
    ::Vpn_t* vpn_;
    ::Timer_t* time_;
    int sender_;
    int receiver_;
    int cotroller_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_typedef_2eproto;
};
// -------------------------------------------------------------------

class Vpn_t final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Vpn_t) */ {
 public:
  inline Vpn_t() : Vpn_t(nullptr) {}
  ~Vpn_t() override;
  explicit PROTOBUF_CONSTEXPR Vpn_t(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vpn_t(const Vpn_t& from);
  Vpn_t(Vpn_t&& from) noexcept
    : Vpn_t() {
    *this = ::std::move(from);
  }

  inline Vpn_t& operator=(const Vpn_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vpn_t& operator=(Vpn_t&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vpn_t& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vpn_t* internal_default_instance() {
    return reinterpret_cast<const Vpn_t*>(
               &_Vpn_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Vpn_t& a, Vpn_t& b) {
    a.Swap(&b);
  }
  inline void Swap(Vpn_t* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vpn_t* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vpn_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vpn_t>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vpn_t& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vpn_t& from) {
    Vpn_t::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vpn_t* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Vpn_t";
  }
  protected:
  explicit Vpn_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // string mac = 2;
  void clear_mac();
  const std::string& mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* mac);
  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(const std::string& value);
  std::string* _internal_mutable_mac();
  public:

  // bool status = 1;
  void clear_status();
  bool status() const;
  void set_status(bool value);
  private:
  bool _internal_status() const;
  void _internal_set_status(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Vpn_t)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_;
    bool status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_typedef_2eproto;
};
// -------------------------------------------------------------------

class Vendor_t final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Vendor_t) */ {
 public:
  inline Vendor_t() : Vendor_t(nullptr) {}
  ~Vendor_t() override;
  explicit PROTOBUF_CONSTEXPR Vendor_t(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vendor_t(const Vendor_t& from);
  Vendor_t(Vendor_t&& from) noexcept
    : Vendor_t() {
    *this = ::std::move(from);
  }

  inline Vendor_t& operator=(const Vendor_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vendor_t& operator=(Vendor_t&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vendor_t& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vendor_t* internal_default_instance() {
    return reinterpret_cast<const Vendor_t*>(
               &_Vendor_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Vendor_t& a, Vendor_t& b) {
    a.Swap(&b);
  }
  inline void Swap(Vendor_t* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vendor_t* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vendor_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vendor_t>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vendor_t& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vendor_t& from) {
    Vendor_t::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vendor_t* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Vendor_t";
  }
  protected:
  explicit Vendor_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacVenFieldNumber = 1,
    kDataFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // string mac_ven = 1;
  void clear_mac_ven();
  const std::string& mac_ven() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac_ven(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac_ven();
  PROTOBUF_NODISCARD std::string* release_mac_ven();
  void set_allocated_mac_ven(std::string* mac_ven);
  private:
  const std::string& _internal_mac_ven() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_ven(const std::string& value);
  std::string* _internal_mutable_mac_ven();
  public:

  // string data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // bool status = 3;
  void clear_status();
  bool status() const;
  void set_status(bool value);
  private:
  bool _internal_status() const;
  void _internal_set_status(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Vendor_t)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_ven_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    bool status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_typedef_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Led_t

// string name = 16;
inline void Led_t::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Led_t::name() const {
  // @@protoc_insertion_point(field_get:Led_t.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Led_t::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Led_t.name)
}
inline std::string* Led_t::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Led_t.name)
  return _s;
}
inline const std::string& Led_t::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Led_t::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Led_t::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Led_t::release_name() {
  // @@protoc_insertion_point(field_release:Led_t.name)
  return _impl_.name_.Release();
}
inline void Led_t::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Led_t.name)
}

// uint64 mac = 17;
inline void Led_t::clear_mac() {
  _impl_.mac_ = uint64_t{0u};
}
inline uint64_t Led_t::_internal_mac() const {
  return _impl_.mac_;
}
inline uint64_t Led_t::mac() const {
  // @@protoc_insertion_point(field_get:Led_t.mac)
  return _internal_mac();
}
inline void Led_t::_internal_set_mac(uint64_t value) {
  
  _impl_.mac_ = value;
}
inline void Led_t::set_mac(uint64_t value) {
  _internal_set_mac(value);
  // @@protoc_insertion_point(field_set:Led_t.mac)
}

// uint32 ep = 18;
inline void Led_t::clear_ep() {
  _impl_.ep_ = 0u;
}
inline uint32_t Led_t::_internal_ep() const {
  return _impl_.ep_;
}
inline uint32_t Led_t::ep() const {
  // @@protoc_insertion_point(field_get:Led_t.ep)
  return _internal_ep();
}
inline void Led_t::_internal_set_ep(uint32_t value) {
  
  _impl_.ep_ = value;
}
inline void Led_t::set_ep(uint32_t value) {
  _internal_set_ep(value);
  // @@protoc_insertion_point(field_set:Led_t.ep)
}

// bool status = 19;
inline void Led_t::clear_status() {
  _impl_.status_ = false;
}
inline bool Led_t::_internal_status() const {
  return _impl_.status_;
}
inline bool Led_t::status() const {
  // @@protoc_insertion_point(field_get:Led_t.status)
  return _internal_status();
}
inline void Led_t::_internal_set_status(bool value) {
  
  _impl_.status_ = value;
}
inline void Led_t::set_status(bool value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:Led_t.status)
}

// -------------------------------------------------------------------

// Sync_t

// bool add = 16;
inline void Sync_t::clear_add() {
  _impl_.add_ = false;
}
inline bool Sync_t::_internal_add() const {
  return _impl_.add_;
}
inline bool Sync_t::add() const {
  // @@protoc_insertion_point(field_get:Sync_t.add)
  return _internal_add();
}
inline void Sync_t::_internal_set_add(bool value) {
  
  _impl_.add_ = value;
}
inline void Sync_t::set_add(bool value) {
  _internal_set_add(value);
  // @@protoc_insertion_point(field_set:Sync_t.add)
}

// bool remove = 17;
inline void Sync_t::clear_remove() {
  _impl_.remove_ = false;
}
inline bool Sync_t::_internal_remove() const {
  return _impl_.remove_;
}
inline bool Sync_t::remove() const {
  // @@protoc_insertion_point(field_get:Sync_t.remove)
  return _internal_remove();
}
inline void Sync_t::_internal_set_remove(bool value) {
  
  _impl_.remove_ = value;
}
inline void Sync_t::set_remove(bool value) {
  _internal_set_remove(value);
  // @@protoc_insertion_point(field_set:Sync_t.remove)
}

// bool sync = 18;
inline void Sync_t::clear_sync() {
  _impl_.sync_ = false;
}
inline bool Sync_t::_internal_sync() const {
  return _impl_.sync_;
}
inline bool Sync_t::sync() const {
  // @@protoc_insertion_point(field_get:Sync_t.sync)
  return _internal_sync();
}
inline void Sync_t::_internal_set_sync(bool value) {
  
  _impl_.sync_ = value;
}
inline void Sync_t::set_sync(bool value) {
  _internal_set_sync(value);
  // @@protoc_insertion_point(field_set:Sync_t.sync)
}

// -------------------------------------------------------------------

// Sw_t

// string name = 16;
inline void Sw_t::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Sw_t::name() const {
  // @@protoc_insertion_point(field_get:Sw_t.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Sw_t::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Sw_t.name)
}
inline std::string* Sw_t::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Sw_t.name)
  return _s;
}
inline const std::string& Sw_t::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Sw_t::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Sw_t::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Sw_t::release_name() {
  // @@protoc_insertion_point(field_release:Sw_t.name)
  return _impl_.name_.Release();
}
inline void Sw_t::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Sw_t.name)
}

// uint32 ep = 17;
inline void Sw_t::clear_ep() {
  _impl_.ep_ = 0u;
}
inline uint32_t Sw_t::_internal_ep() const {
  return _impl_.ep_;
}
inline uint32_t Sw_t::ep() const {
  // @@protoc_insertion_point(field_get:Sw_t.ep)
  return _internal_ep();
}
inline void Sw_t::_internal_set_ep(uint32_t value) {
  
  _impl_.ep_ = value;
}
inline void Sw_t::set_ep(uint32_t value) {
  _internal_set_ep(value);
  // @@protoc_insertion_point(field_set:Sw_t.ep)
}

// uint64 mac = 18;
inline void Sw_t::clear_mac() {
  _impl_.mac_ = uint64_t{0u};
}
inline uint64_t Sw_t::_internal_mac() const {
  return _impl_.mac_;
}
inline uint64_t Sw_t::mac() const {
  // @@protoc_insertion_point(field_get:Sw_t.mac)
  return _internal_mac();
}
inline void Sw_t::_internal_set_mac(uint64_t value) {
  
  _impl_.mac_ = value;
}
inline void Sw_t::set_mac(uint64_t value) {
  _internal_set_mac(value);
  // @@protoc_insertion_point(field_set:Sw_t.mac)
}

// bool status = 19;
inline void Sw_t::clear_status() {
  _impl_.status_ = false;
}
inline bool Sw_t::_internal_status() const {
  return _impl_.status_;
}
inline bool Sw_t::status() const {
  // @@protoc_insertion_point(field_get:Sw_t.status)
  return _internal_status();
}
inline void Sw_t::_internal_set_status(bool value) {
  
  _impl_.status_ = value;
}
inline void Sw_t::set_status(bool value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:Sw_t.status)
}

// -------------------------------------------------------------------

// Ota_t

// bool check_ota = 16;
inline void Ota_t::clear_check_ota() {
  _impl_.check_ota_ = false;
}
inline bool Ota_t::_internal_check_ota() const {
  return _impl_.check_ota_;
}
inline bool Ota_t::check_ota() const {
  // @@protoc_insertion_point(field_get:Ota_t.check_ota)
  return _internal_check_ota();
}
inline void Ota_t::_internal_set_check_ota(bool value) {
  
  _impl_.check_ota_ = value;
}
inline void Ota_t::set_check_ota(bool value) {
  _internal_set_check_ota(value);
  // @@protoc_insertion_point(field_set:Ota_t.check_ota)
}

// bool status = 17;
inline void Ota_t::clear_status() {
  _impl_.status_ = false;
}
inline bool Ota_t::_internal_status() const {
  return _impl_.status_;
}
inline bool Ota_t::status() const {
  // @@protoc_insertion_point(field_get:Ota_t.status)
  return _internal_status();
}
inline void Ota_t::_internal_set_status(bool value) {
  
  _impl_.status_ = value;
}
inline void Ota_t::set_status(bool value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:Ota_t.status)
}

// bool ack = 18;
inline void Ota_t::clear_ack() {
  _impl_.ack_ = false;
}
inline bool Ota_t::_internal_ack() const {
  return _impl_.ack_;
}
inline bool Ota_t::ack() const {
  // @@protoc_insertion_point(field_get:Ota_t.ack)
  return _internal_ack();
}
inline void Ota_t::_internal_set_ack(bool value) {
  
  _impl_.ack_ = value;
}
inline void Ota_t::set_ack(bool value) {
  _internal_set_ack(value);
  // @@protoc_insertion_point(field_set:Ota_t.ack)
}

// -------------------------------------------------------------------

// KeepAlive_t

// .User_t sender = 1;
inline void KeepAlive_t::clear_sender() {
  _impl_.sender_ = 0;
}
inline ::User_t KeepAlive_t::_internal_sender() const {
  return static_cast< ::User_t >(_impl_.sender_);
}
inline ::User_t KeepAlive_t::sender() const {
  // @@protoc_insertion_point(field_get:KeepAlive_t.sender)
  return _internal_sender();
}
inline void KeepAlive_t::_internal_set_sender(::User_t value) {
  
  _impl_.sender_ = value;
}
inline void KeepAlive_t::set_sender(::User_t value) {
  _internal_set_sender(value);
  // @@protoc_insertion_point(field_set:KeepAlive_t.sender)
}

// -------------------------------------------------------------------

// Timer_t

// uint32 day = 15;
inline void Timer_t::clear_day() {
  _impl_.day_ = 0u;
}
inline uint32_t Timer_t::_internal_day() const {
  return _impl_.day_;
}
inline uint32_t Timer_t::day() const {
  // @@protoc_insertion_point(field_get:Timer_t.day)
  return _internal_day();
}
inline void Timer_t::_internal_set_day(uint32_t value) {
  
  _impl_.day_ = value;
}
inline void Timer_t::set_day(uint32_t value) {
  _internal_set_day(value);
  // @@protoc_insertion_point(field_set:Timer_t.day)
}

// uint32 month = 16;
inline void Timer_t::clear_month() {
  _impl_.month_ = 0u;
}
inline uint32_t Timer_t::_internal_month() const {
  return _impl_.month_;
}
inline uint32_t Timer_t::month() const {
  // @@protoc_insertion_point(field_get:Timer_t.month)
  return _internal_month();
}
inline void Timer_t::_internal_set_month(uint32_t value) {
  
  _impl_.month_ = value;
}
inline void Timer_t::set_month(uint32_t value) {
  _internal_set_month(value);
  // @@protoc_insertion_point(field_set:Timer_t.month)
}

// uint32 hour = 17;
inline void Timer_t::clear_hour() {
  _impl_.hour_ = 0u;
}
inline uint32_t Timer_t::_internal_hour() const {
  return _impl_.hour_;
}
inline uint32_t Timer_t::hour() const {
  // @@protoc_insertion_point(field_get:Timer_t.hour)
  return _internal_hour();
}
inline void Timer_t::_internal_set_hour(uint32_t value) {
  
  _impl_.hour_ = value;
}
inline void Timer_t::set_hour(uint32_t value) {
  _internal_set_hour(value);
  // @@protoc_insertion_point(field_set:Timer_t.hour)
}

// uint32 minute = 18;
inline void Timer_t::clear_minute() {
  _impl_.minute_ = 0u;
}
inline uint32_t Timer_t::_internal_minute() const {
  return _impl_.minute_;
}
inline uint32_t Timer_t::minute() const {
  // @@protoc_insertion_point(field_get:Timer_t.minute)
  return _internal_minute();
}
inline void Timer_t::_internal_set_minute(uint32_t value) {
  
  _impl_.minute_ = value;
}
inline void Timer_t::set_minute(uint32_t value) {
  _internal_set_minute(value);
  // @@protoc_insertion_point(field_set:Timer_t.minute)
}

// -------------------------------------------------------------------

// Buffer

// string mac_hub = 1;
inline void Buffer::clear_mac_hub() {
  _impl_.mac_hub_.ClearToEmpty();
}
inline const std::string& Buffer::mac_hub() const {
  // @@protoc_insertion_point(field_get:Buffer.mac_hub)
  return _internal_mac_hub();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Buffer::set_mac_hub(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mac_hub_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Buffer.mac_hub)
}
inline std::string* Buffer::mutable_mac_hub() {
  std::string* _s = _internal_mutable_mac_hub();
  // @@protoc_insertion_point(field_mutable:Buffer.mac_hub)
  return _s;
}
inline const std::string& Buffer::_internal_mac_hub() const {
  return _impl_.mac_hub_.Get();
}
inline void Buffer::_internal_set_mac_hub(const std::string& value) {
  
  _impl_.mac_hub_.Set(value, GetArenaForAllocation());
}
inline std::string* Buffer::_internal_mutable_mac_hub() {
  
  return _impl_.mac_hub_.Mutable(GetArenaForAllocation());
}
inline std::string* Buffer::release_mac_hub() {
  // @@protoc_insertion_point(field_release:Buffer.mac_hub)
  return _impl_.mac_hub_.Release();
}
inline void Buffer::set_allocated_mac_hub(std::string* mac_hub) {
  if (mac_hub != nullptr) {
    
  } else {
    
  }
  _impl_.mac_hub_.SetAllocated(mac_hub, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_hub_.IsDefault()) {
    _impl_.mac_hub_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Buffer.mac_hub)
}

// .User_t sender = 2;
inline void Buffer::clear_sender() {
  _impl_.sender_ = 0;
}
inline ::User_t Buffer::_internal_sender() const {
  return static_cast< ::User_t >(_impl_.sender_);
}
inline ::User_t Buffer::sender() const {
  // @@protoc_insertion_point(field_get:Buffer.sender)
  return _internal_sender();
}
inline void Buffer::_internal_set_sender(::User_t value) {
  
  _impl_.sender_ = value;
}
inline void Buffer::set_sender(::User_t value) {
  _internal_set_sender(value);
  // @@protoc_insertion_point(field_set:Buffer.sender)
}

// .User_t receiver = 3;
inline void Buffer::clear_receiver() {
  _impl_.receiver_ = 0;
}
inline ::User_t Buffer::_internal_receiver() const {
  return static_cast< ::User_t >(_impl_.receiver_);
}
inline ::User_t Buffer::receiver() const {
  // @@protoc_insertion_point(field_get:Buffer.receiver)
  return _internal_receiver();
}
inline void Buffer::_internal_set_receiver(::User_t value) {
  
  _impl_.receiver_ = value;
}
inline void Buffer::set_receiver(::User_t value) {
  _internal_set_receiver(value);
  // @@protoc_insertion_point(field_set:Buffer.receiver)
}

// .User_t cotroller = 4;
inline void Buffer::clear_cotroller() {
  _impl_.cotroller_ = 0;
}
inline ::User_t Buffer::_internal_cotroller() const {
  return static_cast< ::User_t >(_impl_.cotroller_);
}
inline ::User_t Buffer::cotroller() const {
  // @@protoc_insertion_point(field_get:Buffer.cotroller)
  return _internal_cotroller();
}
inline void Buffer::_internal_set_cotroller(::User_t value) {
  
  _impl_.cotroller_ = value;
}
inline void Buffer::set_cotroller(::User_t value) {
  _internal_set_cotroller(value);
  // @@protoc_insertion_point(field_set:Buffer.cotroller)
}

// .Sync_t sync = 5;
inline bool Buffer::_internal_has_sync() const {
  return this != internal_default_instance() && _impl_.sync_ != nullptr;
}
inline bool Buffer::has_sync() const {
  return _internal_has_sync();
}
inline void Buffer::clear_sync() {
  if (GetArenaForAllocation() == nullptr && _impl_.sync_ != nullptr) {
    delete _impl_.sync_;
  }
  _impl_.sync_ = nullptr;
}
inline const ::Sync_t& Buffer::_internal_sync() const {
  const ::Sync_t* p = _impl_.sync_;
  return p != nullptr ? *p : reinterpret_cast<const ::Sync_t&>(
      ::_Sync_t_default_instance_);
}
inline const ::Sync_t& Buffer::sync() const {
  // @@protoc_insertion_point(field_get:Buffer.sync)
  return _internal_sync();
}
inline void Buffer::unsafe_arena_set_allocated_sync(
    ::Sync_t* sync) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sync_);
  }
  _impl_.sync_ = sync;
  if (sync) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Buffer.sync)
}
inline ::Sync_t* Buffer::release_sync() {
  
  ::Sync_t* temp = _impl_.sync_;
  _impl_.sync_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Sync_t* Buffer::unsafe_arena_release_sync() {
  // @@protoc_insertion_point(field_release:Buffer.sync)
  
  ::Sync_t* temp = _impl_.sync_;
  _impl_.sync_ = nullptr;
  return temp;
}
inline ::Sync_t* Buffer::_internal_mutable_sync() {
  
  if (_impl_.sync_ == nullptr) {
    auto* p = CreateMaybeMessage<::Sync_t>(GetArenaForAllocation());
    _impl_.sync_ = p;
  }
  return _impl_.sync_;
}
inline ::Sync_t* Buffer::mutable_sync() {
  ::Sync_t* _msg = _internal_mutable_sync();
  // @@protoc_insertion_point(field_mutable:Buffer.sync)
  return _msg;
}
inline void Buffer::set_allocated_sync(::Sync_t* sync) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sync_;
  }
  if (sync) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sync);
    if (message_arena != submessage_arena) {
      sync = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sync, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sync_ = sync;
  // @@protoc_insertion_point(field_set_allocated:Buffer.sync)
}

// .Ota_t ota = 16;
inline bool Buffer::_internal_has_ota() const {
  return this != internal_default_instance() && _impl_.ota_ != nullptr;
}
inline bool Buffer::has_ota() const {
  return _internal_has_ota();
}
inline void Buffer::clear_ota() {
  if (GetArenaForAllocation() == nullptr && _impl_.ota_ != nullptr) {
    delete _impl_.ota_;
  }
  _impl_.ota_ = nullptr;
}
inline const ::Ota_t& Buffer::_internal_ota() const {
  const ::Ota_t* p = _impl_.ota_;
  return p != nullptr ? *p : reinterpret_cast<const ::Ota_t&>(
      ::_Ota_t_default_instance_);
}
inline const ::Ota_t& Buffer::ota() const {
  // @@protoc_insertion_point(field_get:Buffer.ota)
  return _internal_ota();
}
inline void Buffer::unsafe_arena_set_allocated_ota(
    ::Ota_t* ota) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ota_);
  }
  _impl_.ota_ = ota;
  if (ota) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Buffer.ota)
}
inline ::Ota_t* Buffer::release_ota() {
  
  ::Ota_t* temp = _impl_.ota_;
  _impl_.ota_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Ota_t* Buffer::unsafe_arena_release_ota() {
  // @@protoc_insertion_point(field_release:Buffer.ota)
  
  ::Ota_t* temp = _impl_.ota_;
  _impl_.ota_ = nullptr;
  return temp;
}
inline ::Ota_t* Buffer::_internal_mutable_ota() {
  
  if (_impl_.ota_ == nullptr) {
    auto* p = CreateMaybeMessage<::Ota_t>(GetArenaForAllocation());
    _impl_.ota_ = p;
  }
  return _impl_.ota_;
}
inline ::Ota_t* Buffer::mutable_ota() {
  ::Ota_t* _msg = _internal_mutable_ota();
  // @@protoc_insertion_point(field_mutable:Buffer.ota)
  return _msg;
}
inline void Buffer::set_allocated_ota(::Ota_t* ota) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ota_;
  }
  if (ota) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ota);
    if (message_arena != submessage_arena) {
      ota = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ota, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ota_ = ota;
  // @@protoc_insertion_point(field_set_allocated:Buffer.ota)
}

// .Vpn_t vpn = 17;
inline bool Buffer::_internal_has_vpn() const {
  return this != internal_default_instance() && _impl_.vpn_ != nullptr;
}
inline bool Buffer::has_vpn() const {
  return _internal_has_vpn();
}
inline void Buffer::clear_vpn() {
  if (GetArenaForAllocation() == nullptr && _impl_.vpn_ != nullptr) {
    delete _impl_.vpn_;
  }
  _impl_.vpn_ = nullptr;
}
inline const ::Vpn_t& Buffer::_internal_vpn() const {
  const ::Vpn_t* p = _impl_.vpn_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vpn_t&>(
      ::_Vpn_t_default_instance_);
}
inline const ::Vpn_t& Buffer::vpn() const {
  // @@protoc_insertion_point(field_get:Buffer.vpn)
  return _internal_vpn();
}
inline void Buffer::unsafe_arena_set_allocated_vpn(
    ::Vpn_t* vpn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vpn_);
  }
  _impl_.vpn_ = vpn;
  if (vpn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Buffer.vpn)
}
inline ::Vpn_t* Buffer::release_vpn() {
  
  ::Vpn_t* temp = _impl_.vpn_;
  _impl_.vpn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Vpn_t* Buffer::unsafe_arena_release_vpn() {
  // @@protoc_insertion_point(field_release:Buffer.vpn)
  
  ::Vpn_t* temp = _impl_.vpn_;
  _impl_.vpn_ = nullptr;
  return temp;
}
inline ::Vpn_t* Buffer::_internal_mutable_vpn() {
  
  if (_impl_.vpn_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vpn_t>(GetArenaForAllocation());
    _impl_.vpn_ = p;
  }
  return _impl_.vpn_;
}
inline ::Vpn_t* Buffer::mutable_vpn() {
  ::Vpn_t* _msg = _internal_mutable_vpn();
  // @@protoc_insertion_point(field_mutable:Buffer.vpn)
  return _msg;
}
inline void Buffer::set_allocated_vpn(::Vpn_t* vpn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vpn_;
  }
  if (vpn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vpn);
    if (message_arena != submessage_arena) {
      vpn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vpn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vpn_ = vpn;
  // @@protoc_insertion_point(field_set_allocated:Buffer.vpn)
}

// repeated .Led_t led = 18;
inline int Buffer::_internal_led_size() const {
  return _impl_.led_.size();
}
inline int Buffer::led_size() const {
  return _internal_led_size();
}
inline void Buffer::clear_led() {
  _impl_.led_.Clear();
}
inline ::Led_t* Buffer::mutable_led(int index) {
  // @@protoc_insertion_point(field_mutable:Buffer.led)
  return _impl_.led_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Led_t >*
Buffer::mutable_led() {
  // @@protoc_insertion_point(field_mutable_list:Buffer.led)
  return &_impl_.led_;
}
inline const ::Led_t& Buffer::_internal_led(int index) const {
  return _impl_.led_.Get(index);
}
inline const ::Led_t& Buffer::led(int index) const {
  // @@protoc_insertion_point(field_get:Buffer.led)
  return _internal_led(index);
}
inline ::Led_t* Buffer::_internal_add_led() {
  return _impl_.led_.Add();
}
inline ::Led_t* Buffer::add_led() {
  ::Led_t* _add = _internal_add_led();
  // @@protoc_insertion_point(field_add:Buffer.led)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Led_t >&
Buffer::led() const {
  // @@protoc_insertion_point(field_list:Buffer.led)
  return _impl_.led_;
}

// repeated .Sw_t sw = 19;
inline int Buffer::_internal_sw_size() const {
  return _impl_.sw_.size();
}
inline int Buffer::sw_size() const {
  return _internal_sw_size();
}
inline void Buffer::clear_sw() {
  _impl_.sw_.Clear();
}
inline ::Sw_t* Buffer::mutable_sw(int index) {
  // @@protoc_insertion_point(field_mutable:Buffer.sw)
  return _impl_.sw_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Sw_t >*
Buffer::mutable_sw() {
  // @@protoc_insertion_point(field_mutable_list:Buffer.sw)
  return &_impl_.sw_;
}
inline const ::Sw_t& Buffer::_internal_sw(int index) const {
  return _impl_.sw_.Get(index);
}
inline const ::Sw_t& Buffer::sw(int index) const {
  // @@protoc_insertion_point(field_get:Buffer.sw)
  return _internal_sw(index);
}
inline ::Sw_t* Buffer::_internal_add_sw() {
  return _impl_.sw_.Add();
}
inline ::Sw_t* Buffer::add_sw() {
  ::Sw_t* _add = _internal_add_sw();
  // @@protoc_insertion_point(field_add:Buffer.sw)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Sw_t >&
Buffer::sw() const {
  // @@protoc_insertion_point(field_list:Buffer.sw)
  return _impl_.sw_;
}

// .Timer_t time = 20;
inline bool Buffer::_internal_has_time() const {
  return this != internal_default_instance() && _impl_.time_ != nullptr;
}
inline bool Buffer::has_time() const {
  return _internal_has_time();
}
inline void Buffer::clear_time() {
  if (GetArenaForAllocation() == nullptr && _impl_.time_ != nullptr) {
    delete _impl_.time_;
  }
  _impl_.time_ = nullptr;
}
inline const ::Timer_t& Buffer::_internal_time() const {
  const ::Timer_t* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::Timer_t&>(
      ::_Timer_t_default_instance_);
}
inline const ::Timer_t& Buffer::time() const {
  // @@protoc_insertion_point(field_get:Buffer.time)
  return _internal_time();
}
inline void Buffer::unsafe_arena_set_allocated_time(
    ::Timer_t* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Buffer.time)
}
inline ::Timer_t* Buffer::release_time() {
  
  ::Timer_t* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Timer_t* Buffer::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:Buffer.time)
  
  ::Timer_t* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::Timer_t* Buffer::_internal_mutable_time() {
  
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::Timer_t>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::Timer_t* Buffer::mutable_time() {
  ::Timer_t* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:Buffer.time)
  return _msg;
}
inline void Buffer::set_allocated_time(::Timer_t* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.time_;
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(time);
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:Buffer.time)
}

// -------------------------------------------------------------------

// Vpn_t

// bool status = 1;
inline void Vpn_t::clear_status() {
  _impl_.status_ = false;
}
inline bool Vpn_t::_internal_status() const {
  return _impl_.status_;
}
inline bool Vpn_t::status() const {
  // @@protoc_insertion_point(field_get:Vpn_t.status)
  return _internal_status();
}
inline void Vpn_t::_internal_set_status(bool value) {
  
  _impl_.status_ = value;
}
inline void Vpn_t::set_status(bool value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:Vpn_t.status)
}

// string mac = 2;
inline void Vpn_t::clear_mac() {
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& Vpn_t::mac() const {
  // @@protoc_insertion_point(field_get:Vpn_t.mac)
  return _internal_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Vpn_t::set_mac(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mac_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Vpn_t.mac)
}
inline std::string* Vpn_t::mutable_mac() {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:Vpn_t.mac)
  return _s;
}
inline const std::string& Vpn_t::_internal_mac() const {
  return _impl_.mac_.Get();
}
inline void Vpn_t::_internal_set_mac(const std::string& value) {
  
  _impl_.mac_.Set(value, GetArenaForAllocation());
}
inline std::string* Vpn_t::_internal_mutable_mac() {
  
  return _impl_.mac_.Mutable(GetArenaForAllocation());
}
inline std::string* Vpn_t::release_mac() {
  // @@protoc_insertion_point(field_release:Vpn_t.mac)
  return _impl_.mac_.Release();
}
inline void Vpn_t::set_allocated_mac(std::string* mac) {
  if (mac != nullptr) {
    
  } else {
    
  }
  _impl_.mac_.SetAllocated(mac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_.IsDefault()) {
    _impl_.mac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Vpn_t.mac)
}

// -------------------------------------------------------------------

// Vendor_t

// string mac_ven = 1;
inline void Vendor_t::clear_mac_ven() {
  _impl_.mac_ven_.ClearToEmpty();
}
inline const std::string& Vendor_t::mac_ven() const {
  // @@protoc_insertion_point(field_get:Vendor_t.mac_ven)
  return _internal_mac_ven();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Vendor_t::set_mac_ven(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mac_ven_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Vendor_t.mac_ven)
}
inline std::string* Vendor_t::mutable_mac_ven() {
  std::string* _s = _internal_mutable_mac_ven();
  // @@protoc_insertion_point(field_mutable:Vendor_t.mac_ven)
  return _s;
}
inline const std::string& Vendor_t::_internal_mac_ven() const {
  return _impl_.mac_ven_.Get();
}
inline void Vendor_t::_internal_set_mac_ven(const std::string& value) {
  
  _impl_.mac_ven_.Set(value, GetArenaForAllocation());
}
inline std::string* Vendor_t::_internal_mutable_mac_ven() {
  
  return _impl_.mac_ven_.Mutable(GetArenaForAllocation());
}
inline std::string* Vendor_t::release_mac_ven() {
  // @@protoc_insertion_point(field_release:Vendor_t.mac_ven)
  return _impl_.mac_ven_.Release();
}
inline void Vendor_t::set_allocated_mac_ven(std::string* mac_ven) {
  if (mac_ven != nullptr) {
    
  } else {
    
  }
  _impl_.mac_ven_.SetAllocated(mac_ven, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_ven_.IsDefault()) {
    _impl_.mac_ven_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Vendor_t.mac_ven)
}

// string data = 2;
inline void Vendor_t::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Vendor_t::data() const {
  // @@protoc_insertion_point(field_get:Vendor_t.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Vendor_t::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Vendor_t.data)
}
inline std::string* Vendor_t::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:Vendor_t.data)
  return _s;
}
inline const std::string& Vendor_t::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Vendor_t::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Vendor_t::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Vendor_t::release_data() {
  // @@protoc_insertion_point(field_release:Vendor_t.data)
  return _impl_.data_.Release();
}
inline void Vendor_t::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Vendor_t.data)
}

// bool status = 3;
inline void Vendor_t::clear_status() {
  _impl_.status_ = false;
}
inline bool Vendor_t::_internal_status() const {
  return _impl_.status_;
}
inline bool Vendor_t::status() const {
  // @@protoc_insertion_point(field_get:Vendor_t.status)
  return _internal_status();
}
inline void Vendor_t::_internal_set_status(bool value) {
  
  _impl_.status_ = value;
}
inline void Vendor_t::set_status(bool value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:Vendor_t.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::User_t> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::User_t>() {
  return ::User_t_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_typedef_2eproto
